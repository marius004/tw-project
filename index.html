<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="assets/logo.png">
    <title>Assembly x86 documentation</title>
    <link rel="stylesheet" href="css/global.css">
    <link rel="stylesheet" href="css/sidebar.css">
    <link rel="stylesheet" href="css/documentation.css">
    <link rel="stylesheet" href="css/responsive.css">
    <link rel="stylesheet" href="css/gopher.css">
    <link rel="stylesheet" href="css/modal.css">
    <link rel="stylesheet" href="css/contact.css">
    <script src="js/index.js" defer></script>
</head>   
<body>

    <nav id="sidebar">
      <h2 id="sidebar-title">Assembly x86</h2>
      <ul>
        <li><a class="nav-item" href="#Introduction">Introduction</a></li>
        <li><a class="nav-item" href="#Registers">Registers</a></li>
        <li><a class="nav-item" href="#Memory_and_Addressing_Modes">Memory and Addressing Modes</a></li>
        <li><a class="nav-item" href="#Instructions">Instructions</a></li>
        <li><a class="nav-item" href="#Calling_Convention">Calling Convention</a></li>
        <li><a class="nav-item" href="#Additional_Resources">Additional Resources</a></li>
        <li id="contact-me-dispatcher"><a class="nav-item" href="#Contact_me">Contact me</a></li>
      </ul>
    </nav>

    <main id="documentation">
      <article id="Introduction">
        <h2>Introduction</h2>
        <p>
          This is a version adapted by Quentin Carbonneaux from David Evans' original document. 
          The syntax was changed from Intel to AT&T, the standard syntax on UNIX systems, and the HTML 
          code was purified.This guide describes the basics of 32-bit x86 assembly language programming,
          covering a small but useful subset of the available instructions and assembler directives.
          There are several different assembly languages for generating x86 machine code. The one we will
          use in CS421 is the GNU Assembler (gas) assembler. We will uses the standard AT&T syntax for 
          writing x86 assembly code. The full x86 instruction set is large and complex 
          (Intel's x86 instruction set manuals comprise over 2900 pages), and we do not cover it all in 
          this guide. For example, there is a 16-bit subset of the x86 instruction set. Using the 16-bit 
          programming model can be quite complex. It has a segmented memory model, more restrictions on 
          register usage, and so on. In this guide, we will limit our attention to more modern aspects of 
          x86 programming, and delve into the instruction set only in enough detail to get a basic feel for
          x86 programming.
        </p>
      </article>

      <article id="Registers">
        <h2>Registers</h2>
        <p>
          Modern (i.e 386 and beyond) x86 processors have eight 32-bit general purpose registers, 
          as depicted in Figure 1. The register names are mostly historical. For example, EAX used to
          be called the accumulator since it was used by a number of arithmetic operations, and ECX 
          was known as the counter since it was used to hold a loop index. Whereas most of the registers
          have lost their special purposes in the modern instruction set, by convention, two are reserved
          for special purposes — the stack pointer (ESP) and the base pointer (EBP). For the EAX, EBX, ECX,
          and EDX registers, subsections may be used. For example, the least significant 2 bytes of EAX can
          be treated as a 16-bit register called AX. The least significant byte of AX can be used as a 
          single 8-bit register called AL, while the most significant byte of AX can be used as a single 
          8-bit register called AH. These names refer to the same physical register. When a two-byte quantity
          is placed into DX, the update affects the value of DH, DL, and EDX. These sub-registers are mainly
          hold-overs from older, 16-bit versions of the instruction set. However, they are sometimes convenient 
          when dealing with data that are smaller than 32-bits (e.g. 1-byte ASCII characters).
        </p>
        <img class="toggle-fullscreen-modal" src="./assets/registers.png" alt="registers" style="height: 50vh; display: block;margin: 0 auto;">
      </article>

      <article id="Memory_and_Addressing_Modes">
        <h2>Memory and Addressing Modes</h2>
        <section id="Declaring_Static_Data_Regions">
          <h3>Declaring Static Data Regions</h3>
          <p>
            You can declare static data regions (analogous to global variables) in x86 assembly using 
            special assembler directives for this purpose. Data declarations should be preceded by the 
            .data directive. Following this directive, the directives .byte, .short, and .long can be 
            used to declare one, two, and four byte data locations, respectively. To refer to the address 
            of the data created, we can label them. Labels are very useful and versatile in assembly, 
            they give names to memory locations that will be figured out later by the assembler or the linker.
            This is similar to declaring variables by name, but abides by some lower level rules. For example,
            locations declared in sequence will be located in memory next to one another.
          </p>
          <p>Example declarations:</p>
          <pre class="code">
.data
  var:		
    .byte 64	/* Declare a byte, referred to as location var, containing the value 64. */
    .byte 10	/* Declare a byte with no label, containing the value 10. Its location is var + 1. */
  x:		
    .short 42	/* Declare a 2-byte value initialized to 42, referred to as location x. */
  y:		
    .long 30000 /* Declare a 4-byte value, referred to as location y, initialized to 30000. */
</pre>

            <p>
              Unlike in high level languages where arrays can have many dimensions and are accessed by indices,
              arrays in x86 assembly language are simply a number of cells located contiguously in memory. 
              An array can be declared by just listing the values, as in the first example below. 
              For the special case of an array of bytes, string literals can be used. In case a large 
              area of memory is filled with zeroes the .zero directive can be used.
            </p>

            <p>Some examples:</p>
            <pre class="code">
s:
  .long 1, 2, 3	/* Declare three 4-byte values, initialized to 1, 2, and 3. The value at location s + 8 will be 3. */
barr:
  .zero 10	/* Declare 10 bytes starting at location barr, initialized to 0. */
str:
  .string "hello" /* Declare 6 bytes starting at the address str initialized to the ASCII character values for hello followed by a nul (0) byte. */
</pre>
        </section>
        <section id="Addressing_Memory">
          <h3>Addressing Memory</h3>
          <p>
            Modern x86-compatible processors are capable of addressing up to 232 bytes of memory:
            memory addresses are 32-bits wide. In the examples above, where we used labels to refer to
            memory regions, these labels are actually replaced by the assembler with 32-bit quantities 
            that specify addresses in memory. In addition to supporting referring to memory regions 
            by labels (i.e. constant values), the x86 provides a flexible scheme for computing and 
            referring to memory addresses: up to two of the 32-bit registers and a 32-bit signed constant
            can be added together to compute a memory address. One of the registers can be optionally 
            pre-multiplied by 2, 4, or 8.
          </p>
          <p>
            The addressing modes can be used with many x86 instructions (we'll describe them in the next section). 
            Here we illustrate some examples using the mov instruction that moves data between registers
            and memory. This instruction has two operands: the first is the source and the second specifies
             the destination.
          </p>
          <p>Some examples of mov instructions using address computations are:</p>
          
          <pre class="code">
mov %ebx, var(,1)	/* Move the contents of EBX into the 4 bytes at memory address var.
mov (%ebx), %eax	/* Load 4 bytes from the memory address in EBX into EAX. */
mov -4(%esi), %eax	/* Move 4 bytes at memory address ESI + (-4) into EAX. */ (Note, var is a 32-bit constant). */
mov (%esi,%ebx,4), %edx /* Move the 4 bytes of data at address ESI+4*EBX into EDX. */
mov %cl, (%esi,%eax,1) /* Move the contents of CL into the byte at address ESI+EAX. */
</pre>
          
          <p>Some examples of invalid address calculations include:</p>
          <pre class="code">
mov (%ebx,%ecx,-1), %eax     /* Can only add register values. */
mov %ebx, (%eax,%esi,%edi,1) /* At most 2 registers in address computation. */
</pre>
        </section>
        <section id="Operation_Suffixes">
          <h3>Operation Suffixes</h3>
          <p>
            In general, the intended size of the of the data item at a given memory address can 
            be inferred from the assembly code instruction in which it is referenced. For example, 
            in all of the above instructions, the size of the memory regions could be inferred from the 
            size of the register operand. When we were loading a 32-bit register, the assembler could infer
            that the region of memory we were referring to was 4 bytes wide. When we were storing the value
            of a one byte register to memory, the assembler could infer that we wanted the address to refer 
            to a single byte in memory.
          </p>
          <p>
            However, in some cases the size of a referred-to memory region is ambiguous. Consider the
            instruction mov $2, (%ebx). Should this instruction move the value 2 into the single byte at 
            address EBX? Perhaps it should move the 32-bit integer representation of 2 into the 4-bytes 
            starting at address EBX. Since either is a valid possible interpretation, the assembler must
            be explicitly directed as to which is correct. The size prefixes b, w, and l serve this purpose, 
            indicating sizes of 1, 2, and 4 bytes respectively.
          </p>
          <p>For example:</p>
          <pre class="code">
movb $2, (%ebx)	/* Move 2 into the single byte at the address stored in EBX. */
movw $2, (%ebx)	/* Move the 16-bit integer representation of 2 into the 2 bytes starting at the address in EBX. */
movl $2, (%ebx) /* Move the 32-bit integer representation of 2 into the 4 bytes starting at the address in EBX. */
</pre>
        </section>
      </article>

      <article id="Instructions">
        <h2>Instructions</h2>
        <section id="Instruction_Categories">
          <p>
            Machine instructions generally fall into three categories: data movement, arithmetic/logic,
            and control-flow. In this section, we will look at important examples of x86 instructions 
            from each category. This section should not be considered an exhaustive list of x86 instructions, 
            but rather a useful subset. For a complete list, see Intel's instruction set reference.
          </p>
          <p>We use the following notation:</p>
          <pre class="code">
&lt;reg32&gt; Any 32-bit register (%eax, %ebx, %ecx, %edx, %esi, %edi, %esp, or %ebp)
&lt;reg16&gt;	Any 16-bit register (%ax, %bx, %cx, or %dx)
&lt;reg8&gt;	Any 8-bit register (%ah, %bh, %ch, %dh, %al, %bl, %cl, or %dl)
&lt;reg&gt;	Any register
&lt;mem&gt;	A memory address (e.g., (%eax), 4+var(,1), or (%eax,%ebx,1))
&lt;con32&gt;	Any 32-bit immediate
&lt;con16&gt;	Any 16-bit immediate
&lt;con8&gt;	Any 8-bit immediate
&lt;con&gt;	Any 8-, 16-, or 32-bit immediate
</pre>
          <p>
            In assembly language, all the labels and numeric constants used as immediate operands
            (i.e. not in an address calculation like 3(%eax,%ebx,8)) are always prefixed by a dollar sign.
            When needed, hexadecimal notation can be used with the 0x prefix (e.g. $0xABC).
            Without the prefix, numbers are interpreted in the decimal basis.
          </p>
        </section>
        <section id="Data_Movement_Instructions">
          <h3>Data Movement Instructions</h3>
          <ul class="instructions-list">
            <li class="instruction">
                <strong class="instruction-title">mov</strong>
                <i class="instruction-name">Move</i>
                <p>
                  The mov instruction copies the data item referred to by its first operand 
                  (i.e. register contents, memory contents, or a constant value) into the location
                  referred to by its second operand (i.e. a register or memory). While register-to-register
                  moves are possible, direct memory-to-memory moves are not. In cases where memory transfers
                  are desired, the source memory contents must first be loaded into a register, then can be
                  stored to the destination memory address.
                </p>
                <p>Syntax</p>
                <code>
mov &lt;reg&gt;, &lt;reg&gt;
mov &lt;reg&gt;, &lt;mem&gt;
mov &lt;mem&gt;, &lt;reg&gt;
mov &lt;mem&gt;, &lt;reg&gt;
mov &lt;con&gt;, &lt;reg&gt;
mov &lt;con&gt;, &lt;mem&gt;
</code>
              <p>Examples</p>
              <pre class="code">
mov %ebx, %eax — copy the value in EBX into EAX
movb $5, var(,1) — store the value 5 into the byte at location var
</pre>
            </li>
            <li class="instruction">
                <strong class="instruction-title">push</strong>
                <i class="instruction-name">Push on stack</i>
                <p>
                  The push instruction places its operand onto the top of the hardware supported stack
                  in memory. Specifically, push first decrements ESP by 4, then places its operand into
                  the contents of the 32-bit location at address (%esp). ESP (the stack pointer) is 
                  decremented by push since the x86 stack grows down — i.e. the stack grows from high 
                  addresses to lower addresses.
                </p>
                <p>Syntax</p>
                <pre class="code">
push &lt;reg32&gt;
push &lt;mem&gt;
push &lt;con32&gt;
</pre>
              <p>Examples</p>
              <pre class="code">
push %eax — push eax on the stack
push var(,1) — push the 4 bytes at address var onto the stack
</pre>
            </li>
            <li class="instruction">
                <strong class="instruction-title">pop</strong>
                <i class="instruction-name">Pop from stack</i>
                <p>
                  The pop instruction removes the 4-byte data element from the top of the hardware-supported
                  stack into the specified operand (i.e. register or memory location). It first moves the 
                  4 bytes located at memory location (%esp) into the specified register or memory location, 
                  and then increments ESP by 4.
                </p>
                <p>Syntax</p>
                <pre class="code">
pop &lt;reg32&gt;
pop &lt;mem&gt;
</pre>
              <p>Examples</p>
              <pre class="code">
pop %edi — pop the top element of the stack into EDI.
pop (%ebx) — pop the top element of the stack into memory at the four bytes starting at location EBX.
</pre>
            </li>
            <li class="instruction">
                <strong class="instruction-title">lea</strong>
                <i class="instruction-name">Load effective address</i>
                <p>
                  The lea instruction places the address specified by its first operand into the register
                  specified by its second operand. Note, the contents of the memory location are not loaded,
                  only the effective address is computed and placed into the register. This is useful for 
                  obtaining a pointer into a memory region or to perform simple arithmetic operations.
                </p>
                <p>Syntax</p>
                <pre class="code">
lea &lt;mem&gt; &lt;reg32&gt;
</pre>
              <p>Examples</p>
              <pre class="code">
lea (%ebx,%esi,8), %edi — the quantity EBX+8*ESI is placed in EDI.
lea val(,1), %eax — the value val is placed in EAX.
</pre>
            </li>
          </ul>
        </section>
        <section>
          <h3>Arithmetic and Logic Instructions</h3>
          <ul class="instructions-list">
            <li class="instruction">
              <strong class="instruction-title">add</strong>
              <i class="instruction-name">Integer addition</i>
              <p>
                The add instruction adds together its two operands, storing the result in its second
                operand. Note, whereas both operands may be registers, at most one operand may be a memory 
                location.
              </p>
              <p>Syntax</p>
              <pre class="code">
add &lt;reg&gt;, &lt;reg&gt;
add &lt;mem&gt;, &lt;reg&gt;
add &lt;reg&gt;, &lt;mem&gt;
add &lt;con&gt;, &lt;reg&gt;
add &lt;con&gt;, &lt;mem&gt;
</pre>
              <p>Examples</p>
              <pre class="code">
add $10, %eax — EAX is set to EAX + 10
addb $10, (%eax) — add 10 to the single byte stored at memory address stored in EAX
</pre>
            </li>
            <li class="instruction">
                  <strong class="instruction-title">sub</strong>
                  <i class="instruction-name">Integer subtraction</i>
                  <p>
                    The sub instruction stores in the value of its second operand the result of 
                    subtracting the value of its first operand from the value of its second operand. 
                    As with add, whereas both operands may be registers, at most one operand may be a 
                    memory location.
                  </p>
                  <p>Syntax</p>
                  <pre class="code">
sub &lt;reg&gt;, &lt;reg&gt;
sub &lt;mem&gt;, &lt;reg&gt;
sub &lt;reg&gt;, &lt;mem&gt;
sub &lt;con&gt;, &lt;reg&gt;
sub &lt;con&gt;, &lt;mem&gt;
</pre>
                  <p>Examples</p>
                  <pre class="code">
sub %ah, %al — AL is set to AL - AH
sub $216, %eax — subtract 216 from the value stored in EAX
</pre>
            </li>
            <li class="instruction">
                  <strong class="instruction-title">inc, dec</strong>
                  <i class="instruction-name">Increment, Decrement</i>
                  <p>
                    The inc instruction increments the contents of its operand by one. 
                    The dec instruction decrements the contents of its operand by one.
                  </p>
                  <p>Syntax</p>
                  <pre class="code">
inc &lt;reg&gt;
inc &lt;mem&gt;
dec &lt;reg&gt;
dec &lt;mem&gt;
</pre>
                <p>Examples</p>
                <pre class="code">
dec %eax — subtract one from the contents of EAX
incl var(,1) — add one to the 32-bit integer stored at location var
</pre>
            </li>
            <li class="instruction">
                  <strong class="instruction-title">imul</strong>
                  <i class="instruction-name">Integer multiplication</i>
                  <p>The imul instruction has two basic formats: two-operand (first two syntax listings above) and three-operand (last two syntax listings above).</p>
                  <p>The two-operand form multiplies its two operands together and stores the result in the second operand. The result (i.e. second) operand must be a register.</p>
                  <p>The three operand form multiplies its second and third operands together and stores the result in its last operand. Again, the result operand must be a register. Furthermore, the first operand is restricted to being a constant value.</p>
                  <p>Syntax</p>
                  <pre class="code">
imul &lt;reg32&gt; , &lt;reg32&gt;
imul &lt;mem&gt; , &lt;reg32&gt;
imul &lt;con&gt; , &lt;reg32&gt; , &lt;reg32&gt;
imul &lt;con&gt; , &lt;mem&gt; , &lt;reg32&gt;
</pre>
                <p>Examples</p>
                <pre class="code">
imul (%ebx), %eax — multiply the contents of EAX by the 32-bit contents of the memory at location EBX. Store the result in EAX.
imul $25, %edi, %esi — ESI is set to EDI * 25
</pre>
            </li>
            <li class="instruction">
              <strong class="instruction-title">idiv</strong>
              <i class="instruction-name">Integer division</i>
              <p>
                The idiv instruction divides the contents of the 64 bit integer EDX:EAX 
                (constructed by viewing EDX as the most significant four bytes and EAX as the least 
                significant four bytes) by the specified operand value. The quotient result of the division 
                is stored into EAX, while the remainder is placed in EDX.
              </p>
              <p>Syntax</p>
              <pre class="code">
idiv &lt;reg32&gt;
idiv &lt;mem&gt;
</pre>
            <p>Examples</p>
            <pre class="code">
idiv %ebx — divide the contents of EDX:EAX by the contents of EBX. Place the quotient in EAX and the remainder in EDX.
idivw (%ebx) — divide the contents of EDX:EAS by the 32-bit value stored at the memory location in EBX. Place the quotient in EAX and the remainder in EDX.
</pre>
            </li>
            <li class="instruction">
              <strong class="instruction-title">and, or, xor</strong>
              <i class="instruction-name"> Bitwise logical and, or, and exclusive or</i>
              <p>
                These instructions perform the specified logical operation 
                (logical bitwise and, or, and exclusive or, respectively) on their operands, 
                placing the result in the first operand location.
              </p>
              <p>Syntax</p>
              <pre class="code">
and &lt;reg&gt; , &lt;reg&gt;
and &lt;mem&gt; , &lt;reg&gt;
and &lt;reg&gt; , &lt;mem&gt;
and &lt;con&gt; , &lt;reg&gt;
and &lt;con&gt; , &lt;mem&gt;

xor &lt;reg&gt; , &lt;reg&gt;
xor &lt;mem&gt; , &lt;reg&gt;
xor &lt;reg&gt; , &lt;mem&gt;
xor &lt;con&gt; , &lt;reg&gt;
xor &lt;con&gt; , &lt;mem&gt;

or &lt;reg&gt; , &lt;reg&gt;
or &lt;mem&gt; , &lt;reg&gt;
or &lt;reg&gt; , &lt;mem&gt;
or &lt;con&gt; , &lt;reg&gt;
or &lt;con&gt; , &lt;mem&gt;
</pre>
            <p>Examples</p>
            <pre class="code">
and $0x0f, %eax — clear all but the last 4 bits of EAX.
xor %edx, %edx — set the contents of EDX to zero.
</pre>
            </li>
            <li class="instruction">
              <strong class="instruction-title">not</strong>
              <i class="instruction-name">Bitwise logical not</i>
              <p>Logically negates the operand contents (that is, flips all bit values in the operand).</p>
              <p>Syntax</p>
              <pre class="code">
not &lt;reg&gt;
not &lt;mem&gt;
</pre>
            <p>Examples</p>
            <pre class="code">
not %eax — flip all the bits of EAX
</pre>
            </li>
            <li class="instruction">
              <strong class="instruction-title">neg</strong>
              <i class="instruction-name">Negate</i>
              <p>Performs the two's complement negation of the operand contents.</p>
              <p>Syntax</p>
              <pre class="code">
neg  &lt;reg&gt;
neg &lt;mem&gt;
</pre>
            <p>Examples</p>
            <pre class="code">
neg %eax — EAX is set to (- EAX)
</pre>
            </li>
            <li class="instruction">
              <strong class="instruction-title">shl, shr</strong>
              <i class="instruction-name"> Shift left and right</i>
              <p>
                These instructions shift the bits in their first operand's contents left and right,
                padding the resulting empty bit positions with zeros. The shifted operand can be
                shifted up to 31 places. The number of bits to shift is specified by the second operand,
                which can be either an 8-bit constant or the register CL. In either case, shifts counts 
                of greater then 31 are performed modulo 32.
              </p>
              <p>Syntax</p>
              <pre class="code">
shl  &lt;con8&gt; , &lt;reg&gt;
shl  &lt;con8&gt; , &lt;mem&gt;
shl  %cl , &lt;reg&gt;
shl  %cl , &lt;mem&gt;

shr  &lt;con8&gt; , &lt;reg&gt;
shr  &lt;con8&gt; , &lt;mem&gt;
shr  %cl , &lt;reg&gt;
shr  %cl , &lt;mem&gt;
</pre>
            <p>Examples</p>
            <pre class="code">
shl $1, eax — Multiply the value of EAX by 2 (if the most significant bit is 0)
shr %cl, %ebx — Store in EBX the floor of result of dividing the value of EBX by 2n where n is the value in CL. Caution: for negative integers, it is different from the C semantics of division!
</pre>
            </li>
          </ul>
        </section>
      </article>

      <article id="Calling_Convention">
        <h2>Calling Convention</h2>
        <section>
          <p>
            To allow separate programmers to share code and develop libraries for use by many programs, 
            and to simplify the use of subroutines in general, programmers typically adopt a common calling
            convention. The calling convention is a protocol about how to call and return from routines. 
            For example, given a set of calling convention rules, a programmer need not examine the definition
            of a subroutine to determine how parameters should be passed to that subroutine. Furthermore, 
            given a set of calling convention rules, high-level language compilers can be made to follow 
            the rules, thus allowing hand-coded assembly language routines and high-level language routines 
            to call one another.
          </p>
          <p>
            In practice, many calling conventions are possible. We will describe the widely used C language 
            calling convention. Following this convention will allow you to write assembly language subroutines 
            that are safely callable from C (and C++) code, and will also enable you to call C library functions 
            from your assembly language code.
          </p>
          <p>
            The C calling convention is based heavily on the use of the hardware-supported stack. It is based
            on the push, pop, call, and ret instructions. Subroutine parameters are passed on the stack. 
            Registers are saved on the stack, and local variables used by subroutines are placed in memory 
            on the stack. The vast majority of high-level procedural languages implemented on most processors
            have used similar calling conventions.
          </p>
          <p>
            The calling convention is broken into two sets of rules. The first set of rules is employed by the
            caller of the subroutine, and the second set of rules is observed by the writer of the subroutine 
            (the callee). It should be emphasized that mistakes in the observance of these rules quickly result 
            in fatal program errors since the stack will be left in an inconsistent state; thus meticulous care
            should be used when implementing the call convention in your own subroutines.
          </p>
          <img class="toggle-fullscreen-modal" src="./assets/stack-convention.png" alt="stack convention" style="height: 50vh; display: block;margin: 0 auto;">
          <p>
            A good way to visualize the operation of the calling convention is to draw the contents of the 
            nearby region of the stack during subroutine execution. The image above depicts the contents of the
            stack during the execution of a subroutine with three parameters and three local variables. 
            The cells depicted in the stack are 32-bit wide memory locations, thus the memory addresses of the 
            cells are 4 bytes apart. The first parameter resides at an offset of 8 bytes from the base pointer. 
            Above the parameters on the stack (and below the base pointer), the call instruction placed the 
            return address, thus leading to an extra 4 bytes of offset from the base pointer to the first 
            parameter. When the ret instruction is used to return from the subroutine, it will jump to the 
            return address stored on the stack.
          </p>
        </section>
        <section>
          <h3>Caller Rules</h3>
          <p>To make a subrouting call, the caller should:</p>
          <ol>
            <li>
              Before calling a subroutine, the caller should save the contents of certain registers 
              that are designated caller-saved. The caller-saved registers are EAX, ECX, EDX. Since the 
              called subroutine is allowed to modify these registers, if the caller relies on their values 
              after the subroutine returns, the caller must push the values in these registers onto the stack
              so they can be restore after the subroutine returns.
            </li>
            <li>
              To pass parameters to the subroutine, push them onto the stack before the call. The parameters 
              should be pushed in inverted order (i.e. last parameter first). Since the stack grows down, 
              the first parameter will be stored at the lowest address (this inversion of parameters was 
              historically used to allow functions to be passed a variable number of parameters).
            </li>
            <li>
              To call the subroutine, use the call instruction. This instruction places the return address on
              top of the parameters on the stack, and branches to the subroutine code. This invokes the 
              subroutine, which should follow the callee rules below.
            </li>
          </ol>
          <p>
            After the subroutine returns (immediately following the call instruction), the caller can 
            expect to find the return value of the subroutine in the register EAX. To restore the machine 
            state, the caller should:
          </p>
          <ol>
            <li>
              Remove the parameters from stack. This restores the stack to its state before the call was performed.</li>
            <li>Restore the contents of caller-saved registers (EAX, ECX, EDX) by popping them off of the stack. The caller can assume that no other registers were modified by the subroutine.</li>
          </ol>
          <strong>Example:</strong>
          <p>The code below shows a function call that follows the caller rules. The caller is calling a function myFunc that takes three integer parameters. First parameter is in EAX, the second parameter is the constant 216; the third parameter is in the memory location stored in EBX.</p>
          <pre class="code">
push (%ebx) /* Push last parameter first */
push $216   /* Push the second parameter */
push %eax   /* Push first parameter last */

call myFunc /* Call the function (assume C naming) */

add $12, %esp
</pre>
          <p>
            Note that after the call returns, the caller cleans up the stack using the add instruction. 
            We have 12 bytes (3 parameters * 4 bytes each) on the stack, and the stack grows down. 
            Thus, to get rid of the parameters, we can simply add 12 to the stack pointer.
          </p>
          <p>
            The result produced by myFunc is now available for use in the register EAX. The values of the
            caller-saved registers (ECX and EDX), may have been changed. If the caller uses them after the 
            call, it would have needed to save them on the stack before the call and restore them after it.
          </p>
        </section>
        <section>
          <p>The definition of the subroutine should adhere to the following rules at the beginning of the subroutine:</p>
          <ol>
            <li>
              <p>Push the value of EBP onto the stack, and then copy the value of ESP into EBP using the following instructions:</p>
              <pre class="code">
push %ebp
mov  %esp, %ebp
</pre>
              <p>This initial action maintains the base pointer, EBP. The base pointer is used by convention as a point of reference for finding parameters and local variables on the stack. When a subroutine is executing, the base pointer holds a copy of the stack pointer value from when the subroutine started executing. Parameters and local variables will always be located at known, constant offsets away from the base pointer value. We push the old base pointer value at the beginning of the subroutine so that we can later restore the appropriate base pointer value for the caller when the subroutine returns. Remember, the caller is not expecting the subroutine to change the value of the base pointer. We then move the stack pointer into EBP to obtain our point of reference for accessing parameters and local variables.</p>

            </li>
            <li>
              <p>Next, allocate local variables by making space on the stack. Recall, the stack grows down, so to make space on the top of the stack, the stack pointer should be decremented. The amount by which the stack pointer is decremented depends on the number and size of local variables needed. For example, if 3 local integers (4 bytes each) were required, the stack pointer would need to be decremented by 12 to make space for these local variables (i.e., sub $12, %esp). As with parameters, local variables will be located at known offsets from the base pointer.</p>
            </li>
            <li>
              <p>Next, save the values of the callee-saved registers that will be used by the function. To save registers, push them onto the stack. The callee-saved registers are EBX, EDI, and ESI (ESP and EBP will also be preserved by the calling convention, but need not be pushed on the stack during this step).</p>
            </li>
          </ol>
          <p>After these three actions are performed, the body of the subroutine may proceed. When the subroutine is returns, it must follow these steps:</p>
          <ol>
            <li>Leave the return value in EAX.</li>
            <li>Restore the old values of any callee-saved registers (EDI and ESI) that were modified. The register contents are restored by popping them from the stack. The registers should be popped in the inverse order that they were pushed.</li>
            <li>Deallocate local variables. The obvious way to do this might be to add the appropriate value to the stack pointer (since the space was allocated by subtracting the needed amount from the stack pointer). In practice, a less error-prone way to deallocate the variables is to move the value in the base pointer into the stack pointer: mov %ebp, %esp. This works because the base pointer always contains the value that the stack pointer contained immediately prior to the allocation of the local variables.</li>
            <li>Immediately before returning, restore the caller's base pointer value by popping EBP off the stack. Recall that the first thing we did on entry to the subroutine was to push the base pointer to save its old value.</li>
            <li>Finally, return to the caller by executing a ret instruction. This instruction will find and remove the appropriate return address from the stack.</li>
          </ol>
          <p>Note that the callee's rules fall cleanly into two halves that are basically mirror images of one another. The first half of the rules apply to the beginning of the function, and are commonly said to define the prologue to the function. The latter half of the rules apply to the end of the function, and are thus commonly said to define the epilogue of the function.</p>
          <strong>Example:</strong>
          <p>Here is an example function definition that follows the callee rules:</p>
          <pre class="code">
/* Start the code section */
.text

/* Define myFunc as a global (exported) function. */
.globl myFunc
.type myFunc, @function
myFunc:

  /* Subroutine Prologue */
  push %ebp      /* Save the old base pointer value. */
  mov %esp, %ebp /* Set the new base pointer value. */
  sub $4, %esp   /* Make room for one 4-byte local variable. */
  push %edi      /* Save the values of registers that the function */
  push %esi      /* will modify. This function uses EDI and ESI. */
  /* (no need to save EBX, EBP, or ESP) */

  /* Subroutine Body */
  mov 8(%ebp), %eax   /* Move value of parameter 1 into EAX. */
  mov 12(%ebp), %esi  /* Move value of parameter 2 into ESI. */
  mov 16(%ebp), %edi  /* Move value of parameter 3 into EDI. */

  mov %edi, -4(%ebp)  /* Move EDI into the local variable. */
  add %esi, -4(%ebp)  /* Add ESI into the local variable. */
  add -4(%ebp), %eax  /* Add the contents of the local variable */
                      /* into EAX (final result). */

  /* Subroutine Epilogue */
  pop %esi       /* Recover register values. */
  pop %edi
  mov %ebp, %esp /* Deallocate the local variable. */
  pop %ebp       /* Restore the caller's base pointer value. */
  ret
</pre>
          <p>The subroutine prologue performs the standard actions of saving a snapshot of the stack pointer in EBP (the base pointer), allocating local variables by decrementing the stack pointer, and saving register values on the stack.</p>
          <p>In the body of the subroutine we can see the use of the base pointer. Both parameters and local variables are located at constant offsets from the base pointer for the duration of the subroutines execution. In particular, we notice that since parameters were placed onto the stack before the subroutine was called, they are always located below the base pointer (i.e. at higher addresses) on the stack. The first parameter to the subroutine can always be found at memory location (EBP+8), the second at (EBP+12), the third at (EBP+16). Similarly, since local variables are allocated after the base pointer is set, they always reside above the base pointer (i.e. at lower addresses) on the stack. In particular, the first local variable is always located at (EBP-4), the second at (EBP-8), and so on. This conventional use of the base pointer allows us to quickly identify the use of local variables and parameters within a function body.</p>
          <p>The function epilogue is basically a mirror image of the function prologue. The caller's register values are recovered from the stack, the local variables are deallocated by resetting the stack pointer, the caller's base pointer value is recovered, and the ret instruction is used to return to the appropriate code location in the caller.</p>
        </section>
      </article>

      <section id="Additional_Resources">
        <h3>Additional Resources</h3>

        <div class="card-grid">
          <div class="card">
            <div class="card-image">
              <a href="https://www.youtube.com/watch?v=S-ZDUYMoy3Y">
                <img src="https://img.youtube.com/vi/S-ZDUYMoy3Y/maxresdefault.jpg" alt="Video thumbnail">
              </a>
            </div>
            <div class="card-content">
              <h3 class="card-title">Visualizing Stack Intel Att Assembly</h3>
              <p class="card-description">More about how the stack is often visualized</p>
            </div>
          </div>
          <div class="card">
            <div class="card-image">
              <a href="https://www.youtube.com/watch?v=N0hePXneixM">
                <img src="https://img.youtube.com/vi/N0hePXneixM/maxresdefault.jpg" alt="Video thumbnail">
              </a>
            </div>
            <div class="card-content">
              <h3 class="card-title">Stack and local variables</h3>
              <p class="card-description">More about how a function's stack works under the hood</p>
            </div>
          </div>
          <div class="card">
            <div class="card-image">
              <a href="https://www.youtube.com/watch?v=F58WAnf2gr0">
                <img src="https://img.youtube.com/vi/F58WAnf2gr0/maxresdefault.jpg" alt="Video thumbnail">
              </a>
            </div>
            <div class="card-content">
              <h3 class="card-title">Prologue: Intel x86 Assembly Att Stack</h3>
              <p class="card-description">More about what the 2 lines of prologue do</p>
            </div>
          </div>
          <div class="card">
            <div class="card-image">
              <a href="https://www.youtube.com/watch?v=uyRZRnJLqEY">
                <img src="https://img.youtube.com/vi/N0hePXneixM/maxresdefault.jpg" alt="Video thumbnail">
              </a>
            </div>
            <div class="card-content">
              <h3 class="card-title">GCC Calling Conventions: Intel Assembly Att Stack</h3>
              <p class="card-description">More about GCC Calling Conventions</p>
            </div>
          </div>
          <div class="card">
            <div class="card-image">
              <a href="https://www.youtube.com/watch?v=5iQkR69H_1M">
                <img src="https://img.youtube.com/vi/5iQkR69H_1M/maxresdefault.jpg" alt="Video thumbnail">
              </a>
            </div>
            <div class="card-content">
              <h3 class="card-title">Writing a Function in Assembly #1</h3>
              <p class="card-description">Translating a simple C function into assembly</p>
            </div>
          </div>
          <div class="card">
            <div class="card-image">
              <a href="https://www.youtube.com/watch?v=7ukTs4Bi7hI">
                <img src="https://img.youtube.com/vi/7ukTs4Bi7hI/maxresdefault.jpg" alt="Video thumbnail">
              </a>
            </div>
            <div class="card-content">
              <h3 class="card-title">Writing a Function in Assembly #2</h3>
              <p class="card-description">Translating a simple C function into assembly</p>
            </div>
          </div>
          <div class="card">
            <div class="card-image">
              <a href="https://www.youtube.com/watch?v=seo5Es4pycs">
                <img src="https://img.youtube.com/vi/seo5Es4pycs/maxresdefault.jpg" alt="Video thumbnail">
              </a>
            </div>
            <div class="card-content">
              <h3 class="card-title">Writing a Function in Assembly #3</h3>
              <p class="card-description">Translating a simple C function into assembly</p>
            </div>
          </div>
          <div class="card">
            <div class="card-image">
              <a href="https://www.youtube.com/watch?v=qpyRz5lkRjE">
                <img src="https://img.youtube.com/vi/qpyRz5lkRjE/maxresdefault.jpg" alt="Video thumbnail">
              </a>
            </div>
            <div class="card-content">
              <h3 class="card-title">What Happens When Your Buffers are Too Small</h3>
              <p class="card-description">A simple buffer overflow example</p>
            </div>
          </div>
          <div class="card">
            <div class="card-image">
              <a href="https://www.youtube.com/watch?v=fjMrDDj47E8">
                <img src="https://img.youtube.com/vi/fjMrDDj47E8/maxresdefault.jpg" alt="Video thumbnail">
              </a>
            </div>
            <div class="card-content">
              <h3 class="card-title">Strings in C are getting people HACKED</h3>
              <p class="card-description">Showcasing some vulnerable C functions that you should avoid</p>
            </div>
          </div>
        </div>

        <section>
          <h3>Other articles</h3>
          <ul class="list-group">
            <li class="list-group-item dropdown">
              <a href="https://cs.unibuc.ro/~crusu/asc/" class="dropdown-toggle">cs.unibuc.ro</a>
              <ul class="dropdown-menu">
                <li><a target="_blank" href="https://cs.unibuc.ro/~crusu/asc/Arhitectura%20Sistemelor%20de%20Calcul%20(ASC)%20-%20Laborator%20Partea%200x00.pdf">Introduction to Assembly x86</a></li>
                <li><a target="_blank" href="https://cs.unibuc.ro/~crusu/asc/Arhitectura%20Sistemelor%20de%20Calcul%20(ASC)%20-%20Laborator%20Partea%200x01.pdf">Advanced problems in Assembly x86</a></li>
              </ul>
            </li>
            <li class="list-group-item dropdown">
              <a href="https://www.amazon.com/" class="dropdown-toggle">amazon.com</a>
              <ul class="dropdown-menu">
                <li><a target="_blank" href="https://www.amazon.com/Professional-Assembly-Language-Richard-Blum/dp/0764579010/ref=sr_1_13?crid=1C8EV29RR28P7&keywords=assembly&qid=1680947513&s=books&sprefix=assembly%2Cstripbooks-intl-ship%2C188&sr=1-13">Professional Assembly Language(Richard Blum)</a></li>
                <li><a target="_blank" href="https://www.amazon.com/Mastering-Assembly-Programming-instruction-processor/dp/1787287483/ref=sr_1_14?crid=1C8EV29RR28P7&keywords=assembly&qid=1680947640&s=books&sprefix=assembly%2Cstripbooks-intl-ship%2C188&sr=1-14">Mastering Assembly Programming(Alexey Lyashko)</a></li>
                <li><a target="_blank" href="https://www.amazon.com/Art-64-Bit-Assembly-Language/dp/1718501080/ref=sr_1_3?crid=1C8EV29RR28P7&keywords=assembly&qid=1680947640&s=books&sprefix=assembly%2Cstripbooks-intl-ship%2C188&sr=1-3">The Art of 64-Bit Assembly</a></li>
              </ul>
            </li>
            <li class="list-group-item">
              <a target="_blank" href="https://flint.cs.yale.edu/cs421/papers/x86-asm/asm.html">flint.cs.yale.edu</a>
            </li>
          </ul>
        </section>
      </section>
      
      <section id="gopher-animation">
        <!-- Based on original artwork by http://reneefrench.blogspot.com/ -->
        <svg class="gopher" viewBox="0 -150 1200 1700" fill="none" xmlns="http://www.w3.org/2000/svg">
          <ellipse class="shadow" cx="626" cy="1460" rx="280" ry="50" fill="#9B80B4"/>
          <g class="gopher-animation">
            <path fill-rule="evenodd" clip-rule="evenodd" d="M336.843 527.661C315.681 486.87 305.448 404.203 336.843 387.475C368.239 370.747 422.722 400.089 443.884 440.879C465.047 481.669 464.797 523.3 433.402 540.028C402.007 556.756 358.006 568.451 336.843 527.661Z" fill="#A0C6E0" stroke="#675243" stroke-width="5"/>
            <path fill-rule="evenodd" clip-rule="evenodd" d="M360.931 498.7C348.903 477.633 343.087 434.936 360.931 426.296C378.774 417.657 409.739 432.811 421.767 453.879C433.795 474.946 433.653 496.448 415.809 505.087C397.966 513.727 372.958 519.768 360.931 498.7Z" fill="#C2DFE7"/>
            <path fill-rule="evenodd" clip-rule="evenodd" d="M769.62 479.414C795.431 441.472 862.912 393.883 892.115 414.285C921.318 434.688 920.991 497.214 895.18 535.156C869.369 573.098 832.877 592.215 803.674 571.812C774.471 551.409 743.809 517.356 769.62 479.414Z" fill="#A0C6E0" stroke="#675243" stroke-width="5"/>
            <path fill-rule="evenodd" clip-rule="evenodd" d="M810.602 477.327C824.879 457.169 862.205 431.886 878.359 442.725C894.512 453.565 894.331 486.783 880.054 506.941C865.777 527.099 845.591 537.255 829.438 526.416C813.285 515.576 796.324 497.484 810.602 477.327Z" fill="#C2DFE7"/>
            <g class="arms">
              <path class="left-arm" fill-rule="evenodd" clip-rule="evenodd" d="M222.749 1121.94C200.687 1108.9 196.476 1046.08 213.345 981.617C230.214 917.157 261.774 875.472 283.836 888.513C305.898 901.554 310.108 964.381 293.24 1028.84C276.371 1093.3 244.811 1134.99 222.749 1121.94Z" fill="#CBA992" stroke="#675243" stroke-width="5"/>
              <path class="right-arm" fill-rule="evenodd" clip-rule="evenodd" d="M943.415 887.807C971.105 892.431 1004.6 948.751 1018.23 1013.6C1031.87 1078.45 1020.47 1127.27 992.784 1122.65C965.091 1118.02 931.594 1061.71 917.962 996.855C904.33 932.006 915.726 883.183 943.415 887.807Z" fill="#CBA992" stroke="#675243" stroke-width="5"/>
            </g>
            <path fill-rule="evenodd" clip-rule="evenodd" d="M315.625 747.824C315.625 623.008 450.611 521.824 617.125 521.824C783.639 521.824 918.625 623.008 918.625 747.824C918.625 872.64 783.639 973.824 617.125 973.824C450.611 973.824 315.625 872.64 315.625 747.824Z" fill="#91BAE0" stroke="#91BAE0" stroke-width="8" stroke-linecap="round" stroke-linejoin="round"/>
            <g>
              <path class="right-foot" fill-rule="evenodd" clip-rule="evenodd" d="M758.781 1179.38C791.125 1173.99 826.379 1226.72 837.523 1297.17C848.666 1367.62 831.48 1429.11 799.136 1434.5C766.791 1439.9 731.538 1387.15 720.395 1316.7C709.251 1246.25 726.438 1184.77 758.781 1179.38Z" fill="#CBA992" stroke="#675243" stroke-width="5"/>
              <path class="left-foot" fill-rule="evenodd" clip-rule="evenodd" d="M466.881 1162.04C499.583 1163.72 523.261 1222.91 519.767 1294.25C516.272 1365.59 486.929 1422.06 454.227 1420.38C421.525 1418.69 397.847 1359.5 401.342 1288.16C404.835 1216.83 434.179 1160.36 466.881 1162.04Z" fill="#CBA992" stroke="#675243" stroke-width="5"/>
            </g>
            <path fill-rule="evenodd" clip-rule="evenodd" d="M256.591 922.566C256.591 805.838 230.376 686.684 273.059 605.479C326.597 503.621 491.435 443.598 618.611 443.598C736.731 443.598 850.694 489.391 912.01 577.108C969.341 659.125 961.413 777.054 961.413 904.208C961.413 1028.84 988.568 1164.75 933.418 1253.01C872.125 1351.09 760.602 1369.83 640.291 1369.83C496.24 1369.83 336.422 1300.3 286.233 1169.56C256.787 1092.85 256.591 1019.87 256.591 922.566Z" fill="#A0C6E0" stroke="#675243" stroke-width="5"/>
            <path fill-rule="evenodd" clip-rule="evenodd" d="M252.625 704.326C252.625 619.351 319.359 550.465 401.679 550.465C484 550.465 550.734 619.351 550.734 704.326C550.734 789.301 484 858.187 401.679 858.187C319.359 858.187 252.625 789.301 252.625 704.326Z" fill="white" stroke="#675243" stroke-width="5"/>
            <path fill-rule="evenodd" clip-rule="evenodd" d="M638.625 704.326C638.625 619.351 705.359 550.465 787.679 550.465C870 550.465 936.734 619.351 936.734 704.326C936.734 789.301 870 858.187 787.679 858.187C705.359 858.187 638.625 789.301 638.625 704.326Z" fill="white" stroke="#675243" stroke-width="5"/>
            <path fill-rule="evenodd" clip-rule="evenodd" d="M562.239 754.924C562.633 745.254 573.975 742.057 595.69 742.975C617.405 743.894 626.667 751.302 626.273 760.971C625.88 770.641 616.25 772.24 594.536 771.322C572.821 770.404 561.845 764.593 562.239 754.924Z" fill="#2A2A2A" stroke="#2A2A2A" stroke-width="5"/>
            <path class="mouth" fill-rule="evenodd" clip-rule="evenodd" d="M539.625 873.56C539.625 840.017 563.266 812.824 592.428 812.824C621.59 812.824 645.231 840.017 645.231 873.56C645.231 907.104 621.59 934.296 592.428 934.296C563.266 934.296 539.625 907.104 539.625 873.56Z" fill="#2A2A2A" stroke="#2A2A2A" stroke-width="8"/>
            <path opacity="0.936" fill-rule="evenodd" clip-rule="evenodd" d="M570.23 818.605L589.328 817.582L589.57 866.159L570.472 867.181L570.23 818.605Z" fill="white"/>
            <path opacity="0.936" fill-rule="evenodd" clip-rule="evenodd" d="M595.002 818.32L614.1 817.297L614.343 865.874L595.245 866.896L595.002 818.32Z" fill="white"/>
            <path class="tongue" fill-rule="evenodd" clip-rule="evenodd" d="M564.195 897.419C564.195 886.911 582.691 888.637 599.371 888.637C616.05 888.637 624.953 892.765 624.953 903.274C624.953 913.782 609.655 926.692 592.975 926.692C576.296 926.692 564.195 907.928 564.195 897.419Z" fill="#CC4452"/>
            <path fill-rule="evenodd" clip-rule="evenodd" d="M544.971 796.261C547.106 778.075 570.639 768.322 599.766 771.756C629.966 775.317 649.785 787.939 647.65 806.125C646.43 816.517 640.772 830.207 628.853 830.168C619.912 830.139 606.331 817.835 594.612 815.662C584.825 813.847 568.566 824.64 561.212 822.294C548.019 818.086 543.6 807.938 544.971 796.261Z" fill="#CBA992" stroke="#675243" stroke-width="5"/>
            <path opacity="0.936" fill-rule="evenodd" clip-rule="evenodd" d="M327.625 763.965C327.625 745.992 342.223 731.422 360.231 731.422C378.239 731.422 392.838 745.992 392.838 763.965C392.838 781.938 378.239 796.508 360.231 796.508C342.223 796.508 327.625 781.938 327.625 763.965Z" fill="#262626" stroke="#262626" stroke-width="30"/>
            <path opacity="0.936" fill-rule="evenodd" clip-rule="evenodd" d="M713.625 763.965C713.625 745.992 728.223 731.422 746.231 731.422C764.239 731.422 778.838 745.992 778.838 763.965C778.838 781.938 764.239 796.508 746.231 796.508C728.223 796.508 713.625 781.938 713.625 763.965Z" fill="#262626" stroke="#262626" stroke-width="30"/>
            <path class="belly" fill-rule="evenodd" clip-rule="evenodd" d="M394.625 1114.02C394.625 1019.16 469.271 1016.24 610.91 1023.13C754.74 1030.12 848.824 1050.62 848.824 1145.48C848.824 1240.34 778.649 1302.8 636.865 1302.8C495.081 1302.8 394.625 1208.88 394.625 1114.02Z" fill="#C2DFE7"/>
            <path opacity="0.936" fill-rule="evenodd" clip-rule="evenodd" d="M353.625 736.636C353.625 732.311 359.778 728.805 367.369 728.805C374.959 728.805 381.112 732.311 381.112 736.636C381.112 740.96 374.959 744.466 367.369 744.466C359.778 744.466 353.625 740.96 353.625 736.636Z" fill="white"/>
            <path opacity="0.936" fill-rule="evenodd" clip-rule="evenodd" d="M739.625 736.636C739.625 732.311 745.778 728.805 753.369 728.805C760.959 728.805 767.112 732.311 767.112 736.636C767.112 740.96 760.959 744.466 753.369 744.466C745.778 744.466 739.625 740.96 739.625 736.636Z" fill="white"/>
            <g class="eyes">
              <path class="left-eye" fill-rule="evenodd" clip-rule="evenodd" d="M252.125 703.326C252.125 618.351 318.859 549.465 401.179 549.465C483.5 549.465 550.234 618.351 550.234 703.326C550.234 788.301 483.5 857.187 401.179 857.187C318.859 857.187 252.125 788.301 252.125 703.326Z" fill="#A0C6E0" stroke="#675243" stroke-width="5"/>
              <path class="left-eye" d="M253.293 699.822C298.582 643.976 492.576 652.658 550.735 699.822" stroke="#675243" stroke-width="5"/>
              <path class="right-eye" fill-rule="evenodd" clip-rule="evenodd" d="M638.625 705.275C638.625 620.3 705.359 551.414 787.679 551.414C870 551.414 936.734 620.3 936.734 705.275C936.734 790.25 870 859.136 787.679 859.136C705.359 859.136 638.625 790.25 638.625 705.275Z" fill="#A0C6E0" stroke="#675243" stroke-width="5"/>
              <path class="right-eye" d="M639.293 699.822C684.582 643.976 878.576 652.658 936.735 699.822" stroke="#675243" stroke-width="5"/>
            </g>
        </g>
        </svg>
      </section>

      <!-- Modal -->
      <section>
        <div id="image-modal" class="modal">
          <span class="close">&times;</span>
          <img class="modal-content">
          <div id="caption"></div>
        </div>
      </section>

      <!-- Contact me -->
      <section id="Contact_me">
        <span id="close-form">&times;</span>
        <h2 class="form-title">Contact me</h2>
        <p class="form-description">Contact me if you have any questions about Assembly</p>
        <form onsubmit="handleSubmit(event)">
          <label for="first-name">First Name:</label> 
          <input type="text" id="first-name" name="first-name" required> <br />
          <label for="last-name">Last Name:</label> 
          <input type="text" id="last-name" name="last-name" required> <br/>
          <label for="email">Email:</label> 
          <input type="text" id="email" name="email" required> <br/>
          <label for="message">Message:</label> <br/>
          <textarea id="message" name="message" required></textarea> <br/>
          <button type="submit">Submit</button>
        </form>
      </section>

      <footer>
        <p style="text-align: center">Scarlat Marius &copy;</p>
      </footer>
    </main>
  </body>
</html>